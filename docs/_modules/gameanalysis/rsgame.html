
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>gameanalysis.rsgame &#8212; Game Analysis 8.1.0 documentation</title>
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Game Analysis 8.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">gameanalysis.rsgame</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for gameanalysis.rsgame</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Module for base role symmetric game structures</span>

<span class="sd">Role symmetric games have a number of common attributes and functions that are</span>
<span class="sd">defined in the RsGame class that actual RsGame interfaces should support. In</span>
<span class="sd">addition, an implementation of an EmptyGame is provided for convenience</span>
<span class="sd">purposes. Note, that the constructor to EmptyGame (and most games) should not</span>
<span class="sd">be called, and instead, various convenience functions to create EmptyGames that</span>
<span class="sd">start with the prefix `emptygame` should be called instead.</span>

<span class="sd">Most structures in a role symmetric game are an array of length</span>
<span class="sd">game.num_strats, that lists a value for every strategy in the game. In this</span>
<span class="sd">form, each roles strategies are contiguous. To aggregate elements by role, it</span>
<span class="sd">is helpful to use numpy ufuncs, such as `np.add.reduceat(profile,</span>
<span class="sd">game.role_starts)` will add up all of the players in each role of a profile.</span>
<span class="sd">`np.split(profile, game.role_starts[1:])` will return a list where each element</span>
<span class="sd">is that role&#39;s data. To convert a role array into a strategy array, one can do</span>
<span class="sd">something like `role_array.repeat(game.num_role_strats)`.</span>

<span class="sd">As a general rule, any attribute of a game that begins with `num_` is an actual</span>
<span class="sd">attribute instead of a getter function. Attributes that have the world role in</span>
<span class="sd">them tend to be arrays of size `num_roles` and attributes that have `strat` in</span>
<span class="sd">the name tend to be arrays of size `num_strats`.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># pylint: disable=too-many-lines</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">string</span>
<span class="kn">import</span> <span class="nn">collections.abc</span> <span class="k">as</span> <span class="nn">cabc</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.random</span> <span class="k">as</span> <span class="nn">rand</span>
<span class="kn">import</span> <span class="nn">scipy.special</span> <span class="k">as</span> <span class="nn">sps</span>

<span class="kn">from</span> <span class="nn">gameanalysis</span> <span class="kn">import</span> <span class="n">gamereader</span>
<span class="kn">from</span> <span class="nn">gameanalysis</span> <span class="kn">import</span> <span class="n">utils</span>


<span class="k">class</span> <span class="nc">_StratArray</span><span class="p">(</span>
    <span class="n">abc</span><span class="o">.</span><span class="n">ABC</span>
<span class="p">):</span>  <span class="c1"># pylint: disable=too-many-public-methods,too-many-instance-attributes</span>
    <span class="sd">&quot;&quot;&quot;A class with knowledge of the number of strategies per role</span>

<span class="sd">    This has methods common to working with strategy arrays, which essentially</span>
<span class="sd">    represent points in a simplotope (a cross product of simplicies), or points</span>
<span class="sd">    in a discretized simplotope.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    role_names : (str,)</span>
<span class="sd">        The name of each role. Names must be unique, sorted, and can only</span>
<span class="sd">        contain printable ascii characters less semi-colon and colon.</span>
<span class="sd">    strat_names : ((str,),)</span>
<span class="sd">        The name of each strategy for each role. Must be the same length as</span>
<span class="sd">        role_names. Names must be sorted and unique per role, and can only</span>
<span class="sd">        contain printable ascii characters less semi-colon and comma. Must have</span>
<span class="sd">        at lease one strategy per role.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">role_names</span><span class="p">,</span> <span class="n">strat_names</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">role_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>  <span class="c1"># pragma: no branch</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strat_names</span><span class="p">),</span> <span class="nb">int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">role_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">role_names</span> <span class="o">=</span> <span class="n">role_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strat_names</span> <span class="o">=</span> <span class="n">strat_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_named_role_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">r</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_role_strat_index</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                    <span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strats</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">strats</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strat_names</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_role_strat_dev_index</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                    <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                        <span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">strats</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strats</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">strats</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strat_names</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">role_indices</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">role_strat_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;role and strat names indexed by role strat&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                <span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ses</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">ses</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strat_names</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">num_all_restrictions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of unique restrictions&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">num_pure_restrictions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of pure restrictions</span>

<span class="sd">        A pure restrictions has exactly one strategy per role.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">num_strat_devs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of deviations for each strategy&quot;&quot;&quot;</span>
        <span class="n">devs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">)</span>
        <span class="n">devs</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">devs</span>

    <span class="nd">@property</span>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">num_role_devs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of deviations for each role&quot;&quot;&quot;</span>
        <span class="n">devs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">devs</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">devs</span>

    <span class="nd">@property</span>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">num_devs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The total number of deviations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_devs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">dev_strat_starts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The start index for each strategy deviation&quot;&quot;&quot;</span>
        <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strat_devs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">starts</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">starts</span>

    <span class="nd">@property</span>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">dev_role_starts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The start index for each role deviation&quot;&quot;&quot;</span>
        <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_devs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">starts</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">starts</span>

    <span class="nd">@property</span>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">dev_from_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The strategy deviating from for each deviation&quot;&quot;&quot;</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strat_devs</span><span class="p">)</span>
        <span class="n">inds</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inds</span>

    <span class="nd">@property</span>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">dev_to_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The strategy deviating to for each deviation&quot;&quot;&quot;</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">inds</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inds</span>

    <span class="k">def</span> <span class="nf">all_restrictions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all valid restrictions&quot;&quot;&quot;</span>
        <span class="n">role_subs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">num_strats</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_strats</span><span class="p">))</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">num_strats</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">acartesian2</span><span class="p">(</span><span class="o">*</span><span class="n">role_subs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pure_restrictions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns every pure restriction in a game</span>

<span class="sd">        A pure restriction has only one strategy per role. This returns the</span>
<span class="sd">        pure restrictions in sorted order based off of role and strategy.&quot;&quot;&quot;</span>
        <span class="n">role_rests</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">num_strats</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> <span class="k">for</span> <span class="n">num_strats</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">acartesian2</span><span class="p">(</span><span class="o">*</span><span class="n">role_rests</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">random_restriction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">strat_prob</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a random restriction</span>

<span class="sd">        See random_restrictions&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_restrictions</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">strat_prob</span><span class="o">=</span><span class="n">strat_prob</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">)[</span>
            <span class="mi">0</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">random_restrictions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">strat_prob</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return random restrictions</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        num_samples : int</span>
<span class="sd">            The number of restrictions to be returned.</span>
<span class="sd">        strat_prob : float or [float], optional</span>
<span class="sd">            The probability that a given strategy is in support. If</span>
<span class="sd">            `strat_prob` is None, supports will be sampled uniformly. This can</span>
<span class="sd">            either be a scalar, or an iterable of length `num_roles`.</span>
<span class="sd">        normalize : bool, optional</span>
<span class="sd">            If true, the strategy probabilities are normalized, so that the</span>
<span class="sd">            conditional probability of any strategy in support equals</span>
<span class="sd">            `strat_prob`. The probability for any strategy must be at least `1</span>
<span class="sd">            / num_role_strats` for its role. Individual strategy probabilities</span>
<span class="sd">            are thresholded to this value when normalize is set to true.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">strat_prob</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">strat_prob</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span>
                <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">strat_prob_pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">strat_prob</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span><span class="p">),</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span>
            <span class="p">)</span>
            <span class="n">strat_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">strats</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">,</span> <span class="n">strat_prob_pre</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">strats</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Special case</span>
                    <span class="n">strat_prob</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="n">poly</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">binom</span><span class="p">(</span><span class="n">strats</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">strats</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">strats</span>
                <span class="n">poly</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">poly</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">poly</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">prob</span>
                <span class="n">roots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
                <span class="n">strat_prob</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">roots</span><span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">roots</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">roots</span> <span class="o">&lt;=</span> <span class="n">prob</span><span class="p">)</span>
                <span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
        <span class="n">rands</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">num_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">))</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">rands</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">strat_prob</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rands</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_restriction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">restrict</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Verify that a restriction is valid&quot;&quot;&quot;</span>
        <span class="n">restrict</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">restrict</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
            <span class="n">restrict</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,</span> <span class="s2">&quot;restriction must have valid shape&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">restrict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_pure_restriction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">restrict</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test is restriction is pure&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">restrict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_pure_restriction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">restrict</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Verify a restriction is pure&quot;&quot;&quot;</span>
        <span class="n">restrict</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">restrict</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_restriction</span><span class="p">(</span><span class="n">restrict</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pure_restriction</span><span class="p">(</span>
            <span class="n">restrict</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">trim_mixture_support</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Trims strategies played less than supp_thresh from the support&quot;&quot;&quot;</span>
        <span class="n">mixture</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mixture</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
            <span class="n">mixture</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,</span> <span class="s2">&quot;mixtures must have valid shape&quot;</span>
        <span class="p">)</span>
        <span class="n">mixture</span> <span class="o">*=</span> <span class="n">mixture</span> <span class="o">&gt;=</span> <span class="n">thresh</span>
        <span class="n">mixture</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">mixture</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">,</span> <span class="n">axis</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">mixture</span>

    <span class="k">def</span> <span class="nf">trim_mixture_precision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reduce precision of mixture</span>

<span class="sd">        This trims the mixture so that it lies on the discretized space, where</span>
<span class="sd">        every component is an integer multiple of resolution. By default, trim</span>
<span class="sd">        mixture so every component is only accurate to 1 out of 1000, making it</span>
<span class="sd">        convenient for serialization. This function returns a valid mixture</span>
<span class="sd">        with the minimum absolute error to the input mixture.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mixture</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mixture</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">ires</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">)</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_mixture</span><span class="p">(</span><span class="n">mixture</span><span class="p">),</span> <span class="s2">&quot;must pass mixtures&quot;</span><span class="p">)</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">ires</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">),</span> <span class="s2">&quot;resolution must be integer inverse&quot;</span>
        <span class="p">)</span>
        <span class="n">pmix</span> <span class="o">=</span> <span class="n">mixture</span> <span class="o">*</span> <span class="n">ires</span>
        <span class="n">imix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">pmix</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">imix</span> <span class="o">-</span> <span class="n">pmix</span>
        <span class="n">incs</span> <span class="o">=</span> <span class="n">ires</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">imix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rmix</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">inc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">imix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
            <span class="n">incs</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">inc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rmix</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">inc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)[:</span><span class="n">inc</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">imix</span> <span class="o">/</span> <span class="n">ires</span>

    <span class="k">def</span> <span class="nf">minimum_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">min_prob</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ensure each strategy is played with `min_prob`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">min_prob</span> <span class="o">+</span> <span class="n">mixture</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
            <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span> <span class="o">*</span> <span class="n">min_prob</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_mixture</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Verify that a mixture is valid for game&quot;&quot;&quot;</span>
        <span class="n">mixture</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mixture</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
            <span class="n">mixture</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,</span> <span class="s2">&quot;mixture must have valid shape&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mixture</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">mixture</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="n">axis</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_pure_mixture</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Verify a mixture is pure&quot;&quot;&quot;</span>
        <span class="n">mixture</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mixture</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_mixture</span><span class="p">(</span><span class="n">mixture</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pure_restriction</span><span class="p">(</span>
            <span class="n">mixture</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">mixture_project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Project an array into mixture space&quot;&quot;&quot;</span>
        <span class="n">mixture</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mixture</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">utils</span><span class="o">.</span><span class="n">simplex_project</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">mixture</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">],</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">mixture_to_simplex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="p">):</span>  <span class="c1"># pylint: disable=too-many-locals</span>
        <span class="sd">&quot;&quot;&quot;Convert a mixture to a simplex</span>

<span class="sd">        The simplex will have dimension `num_role_strats - num_roles + 1`. This</span>
<span class="sd">        uses the ray tracing homotopy. The uniform mixtures are aligned, and</span>
<span class="sd">        then rays are extended to the edges to convert proportionally along</span>
<span class="sd">        those rays on each object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This uses a simple ray alignment algorithm. First line up the uniform</span>
<span class="sd">        simplex and the uniform mixture, then define a vector in the mixture as</span>
<span class="sd">        all but the last probabilities in each role. Now trace a line from the</span>
<span class="sd">        uniform mixture to the current mixture to the edge of the mixture, and</span>
<span class="sd">        record what proportion of along that vector the point of interest was.</span>
<span class="sd">        Copy that gradient to the simplex, trace it to the boundary, and take</span>
<span class="sd">        the point the proportion of the way to the edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This is relatively simple despite looking verbose. It&#39;s going to</span>
        <span class="c1"># store the ray as the direction from the uniform mixture to the</span>
        <span class="c1"># current mixture (grad)</span>
        <span class="n">mixture</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mixture</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniform_mixture</span><span class="p">()</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="n">mixture</span> <span class="o">-</span> <span class="n">center</span>
        <span class="c1"># Then we compute alpha, which is the constant to multiply grad by to</span>
        <span class="c1"># get a point on an edge, in some sense this is the maximum weighting</span>
        <span class="c1"># of the ray, and all valid points lie on w * grad, w \in [0, alpha]</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="n">alphas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">grad</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">center</span> <span class="o">/</span> <span class="n">grad</span><span class="p">)</span>
        <span class="n">alphas</span><span class="p">[</span><span class="n">alphas</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">alpha_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">alphas</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">alpha_inds</span><span class="o">.</span><span class="n">flat</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">alpha_inds</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="n">alphas</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">alphas</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">alpha_inds</span><span class="p">]</span>

        <span class="c1"># Now compute the simplex gradient, which just copies the unconstrained</span>
        <span class="c1"># gradients for every simplex in the simplotope, and then computes the</span>
        <span class="c1"># final element so the gradient sums to 0 (necessary to stay on the</span>
        <span class="c1"># simplex) This is done by simply deleting the last element of each</span>
        <span class="c1"># role except the last (role_starts[1:] - 1)</span>
        <span class="n">simp_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">simp_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">simp_dim</span><span class="p">)</span> <span class="o">/</span> <span class="n">simp_dim</span>
        <span class="n">simp_grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">grad</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">simp_grad</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">simp_grad</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Then we compute alpha the same way for the simplex, but this is in</span>
        <span class="c1"># terms of the simp_grad.</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="n">simp_alphas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">simp_grad</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">simp_center</span> <span class="o">/</span> <span class="n">simp_grad</span>
            <span class="p">)</span>
        <span class="n">simp_alphas</span><span class="p">[</span><span class="n">simp_alphas</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">simp_alpha_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">simp_alphas</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">simp_alpha_inds</span><span class="o">.</span><span class="n">flat</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">simp_alpha_inds</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="n">simp_alphas</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">simp_alpha</span> <span class="o">=</span> <span class="n">simp_alphas</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">simp_alpha_inds</span><span class="p">]</span>
        <span class="c1"># The point on the simplex is going to be the ratio of the alphas,</span>
        <span class="c1"># where we account for when their both infinite. They&#39;re infinite when</span>
        <span class="c1"># the mixture is uniform, and when it&#39;s uniform there&#39;s no ray so we</span>
        <span class="c1"># don&#39;t change the projection.</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">isposinf</span><span class="p">(</span><span class="n">simp_alpha</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isposinf</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">simp_alpha</span> <span class="o">/</span> <span class="n">alpha</span>
            <span class="p">)</span>
        <span class="n">simp</span> <span class="o">=</span> <span class="n">simp_center</span> <span class="o">+</span> <span class="n">ratio</span> <span class="o">*</span> <span class="n">simp_grad</span>
        <span class="n">simp</span> <span class="o">*=</span> <span class="n">simp</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">simp</span> <span class="o">/</span> <span class="n">simp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mixture_from_simplex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a simplex back into a valid mixture</span>

<span class="sd">        This is the inverse function of mixture_to_simplex.&quot;&quot;&quot;</span>
        <span class="c1"># See to_simplex for an understanding of what these steps are doing.</span>
        <span class="n">simp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">simp</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">simp_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">simp_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">simp_dim</span><span class="p">)</span> <span class="o">/</span> <span class="n">simp_dim</span>
        <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniform_mixture</span><span class="p">()</span>
        <span class="n">simp_grad</span> <span class="o">=</span> <span class="n">simp</span> <span class="o">-</span> <span class="n">simp_center</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="n">simp_alphas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">simp_grad</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">simp_center</span> <span class="o">/</span> <span class="n">simp_grad</span>
            <span class="p">)</span>
        <span class="n">simp_alphas</span><span class="p">[</span><span class="n">simp_alphas</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">simp_alpha_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">simp_alphas</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">simp_alpha_inds</span><span class="o">.</span><span class="n">flat</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">simp_alpha_inds</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="n">simp_alphas</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">simp_alpha</span> <span class="o">=</span> <span class="n">simp_alphas</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">simp_alpha_inds</span><span class="p">]</span>

        <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
            <span class="n">simp_grad</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">grad</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">grad</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span>
            <span class="n">grad</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="n">alphas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">grad</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">center</span> <span class="o">/</span> <span class="n">grad</span><span class="p">)</span>
        <span class="n">alphas</span><span class="p">[</span><span class="n">alphas</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">alpha_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">alphas</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">alpha_inds</span><span class="o">.</span><span class="n">flat</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">alpha_inds</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="n">alphas</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">alphas</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">alpha_inds</span><span class="p">]</span>  <span class="c1"># &gt;= 1</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">isposinf</span><span class="p">(</span><span class="n">simp_alpha</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isposinf</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">/</span> <span class="n">simp_alpha</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim_mixture_support</span><span class="p">(</span><span class="n">center</span> <span class="o">+</span> <span class="n">ratio</span> <span class="o">*</span> <span class="n">grad</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">uniform_mixture</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the uniform mixed profile&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">random_mixture</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a random mixture</span>

<span class="sd">        See random_mixtures&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_mixtures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">random_mixtures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a random mixed profile</span>

<span class="sd">        Mixed profiles are sampled from a Dirichlet distribution with parameter</span>
<span class="sd">        alpha. If alpha = 1 (the default) this is a uniform distribution over</span>
<span class="sd">        the simplex for each role. Alpha \\in (0, 1) is baised towards high</span>
<span class="sd">        entropy mixtures, i.e. mixtures where one strategy is played in</span>
<span class="sd">        majority. Alpha \\in (1, oo) is baised towards low entropy (uniform)</span>
<span class="sd">        mixtures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mixtures</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">))</span>
        <span class="n">mixtures</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">mixtures</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">,</span> <span class="mi">1</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">mixtures</span>

    <span class="k">def</span> <span class="nf">random_sparse_mixture</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">support_prob</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a random sparse mixture</span>

<span class="sd">        See random_sparse_mixtures&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_sparse_mixtures</span><span class="p">(</span>
            <span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">support_prob</span><span class="o">=</span><span class="n">support_prob</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">random_sparse_mixtures</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">support_prob</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a random sparse mixed profile</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        num_samples : int</span>
<span class="sd">            The number of mixtures to be returned.</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            Mixed profiles are sampled from a dirichlet distribution with</span>
<span class="sd">            parameter alpha. If alpha = 1 (the default) this is a uniform</span>
<span class="sd">            distribution over the simplex for each role. Alpha \\in (0, 1) is</span>
<span class="sd">            baised towards high entropy mixtures, i.e. mixtures where one</span>
<span class="sd">            strategy is played in majority. Alpha \\in (1, oo) is baised towards</span>
<span class="sd">            low entropy (uniform) mixtures.</span>
<span class="sd">        support_prob : float or [float], optional</span>
<span class="sd">            The probability that a given strategy is in support. If support</span>
<span class="sd">            prob is None, supports will be sampled uniformly.</span>
<span class="sd">        normalize : bool, optional</span>
<span class="sd">            If true, the mixtures are normalized, so that the conditional</span>
<span class="sd">            probability of any strategy in support equals support prob. If</span>
<span class="sd">            true, the support_prob for any role must be at least `1 /</span>
<span class="sd">            num_role_strats`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mixtures</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">))</span>
        <span class="n">mixtures</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_restrictions</span><span class="p">(</span>
            <span class="n">num_samples</span><span class="p">,</span> <span class="n">strat_prob</span><span class="o">=</span><span class="n">support_prob</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span>
        <span class="p">)</span>
        <span class="n">mixtures</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">mixtures</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">,</span> <span class="mi">1</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">mixtures</span>

    <span class="k">def</span> <span class="nf">biased_mixtures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="mf">0.9</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generates mixtures biased towards one strategy for each role</span>

<span class="sd">        Each role has one strategy played with probability bias; the remaining</span>
<span class="sd">        1-bias probability is distributed uniformly over the remaining S or S-1</span>
<span class="sd">        strategies. If there&#39;s only one strategy, it is played with probability</span>
<span class="sd">        1.&quot;&quot;&quot;</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">bias</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;probabilities must be between zero and one&quot;</span><span class="p">)</span>

        <span class="n">role_mixtures</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">num_strats</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num_strats</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mixture</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mixture</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">num_strats</span><span class="p">,)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">bias</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_strats</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">mixture</span><span class="p">,</span> <span class="n">bias</span><span class="p">)</span>
            <span class="n">role_mixtures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mixture</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">acartesian2</span><span class="p">(</span><span class="o">*</span><span class="n">role_mixtures</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">role_biased_mixtures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="mf">0.9</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generates mixtures where one role-strategy is played with bias</span>

<span class="sd">        If no roles have more than one strategy (a degenerate game), then this</span>
<span class="sd">        returns nothing.&quot;&quot;&quot;</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">bias</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;probabilities must be between zero and one&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span><span class="p">))</span>

        <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">mixes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniform_mixture</span><span class="p">()[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">prof_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">strat_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">num_strats</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num_strats</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">view</span> <span class="o">=</span> <span class="n">mixes</span><span class="p">[</span>
                    <span class="n">prof_offset</span> <span class="p">:</span> <span class="n">prof_offset</span> <span class="o">+</span> <span class="n">num_strats</span><span class="p">,</span>
                    <span class="n">strat_offset</span> <span class="p">:</span> <span class="n">strat_offset</span> <span class="o">+</span> <span class="n">num_strats</span><span class="p">,</span>
                <span class="p">]</span>
                <span class="n">view</span><span class="o">.</span><span class="n">fill</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">bias</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_strats</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">view</span><span class="p">,</span> <span class="n">bias</span><span class="p">)</span>
                <span class="n">prof_offset</span> <span class="o">+=</span> <span class="n">num_strats</span>
            <span class="n">strat_offset</span> <span class="o">+=</span> <span class="n">num_strats</span>
        <span class="k">return</span> <span class="n">mixes</span>

    <span class="k">def</span> <span class="nf">pure_mixtures</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns all mixtures where the probability is either 1 or 0.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pure_restrictions</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">grid_mixtures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns all of the mixtures in a grid with n points</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        num_points : int &gt; 1</span>
<span class="sd">            The number of points to have along one dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">num_points</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Must have at least two points on a dimensions&quot;</span><span class="p">)</span>
        <span class="n">role_mixtures</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">acomb</span><span class="p">(</span><span class="n">num_strats</span><span class="p">,</span> <span class="n">num_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">num_strats</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">acartesian2</span><span class="p">(</span><span class="o">*</span><span class="n">role_mixtures</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">role_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">role</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the index of a role by name&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_named_role_index</span><span class="p">[</span><span class="n">role</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">role_strat_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">role</span><span class="p">,</span> <span class="n">strat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the index of a role strat pair&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_role_strat_index</span><span class="p">[</span><span class="n">role</span><span class="p">,</span> <span class="n">strat</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">role_strat_dev_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">role</span><span class="p">,</span> <span class="n">strat</span><span class="p">,</span> <span class="n">dev</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the index of a role strat deviating strat pair</span>

<span class="sd">        `dev` and `strat` must both be strategies in role, and be distinct.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_role_strat_dev_index</span><span class="p">[</span><span class="n">role</span><span class="p">,</span> <span class="n">strat</span><span class="p">,</span> <span class="n">dev</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">strat_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">role_strat_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the strategy name from a full index&quot;&quot;&quot;</span>
        <span class="n">role_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_indices</span><span class="p">[</span><span class="n">role_strat_index</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strat_names</span><span class="p">[</span><span class="n">role_index</span><span class="p">][</span>
            <span class="n">role_strat_index</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">[</span><span class="n">role_index</span><span class="p">]</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">mixture_from_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a json mixture into an array&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">dest</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="s2">&quot;dest dtype must be floating&quot;</span><span class="p">)</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
                <span class="n">dest</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,),</span> <span class="s2">&quot;dest shape must be num strats&quot;</span>
            <span class="p">)</span>
        <span class="n">dest</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">role</span><span class="p">,</span> <span class="n">strats</span> <span class="ow">in</span> <span class="n">mixture</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">strat</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span> <span class="n">strats</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">dest</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">role_strat_index</span><span class="p">(</span><span class="n">role</span><span class="p">,</span> <span class="n">strat</span><span class="p">)]</span> <span class="o">=</span> <span class="n">prob</span>

        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
            <span class="ow">not</span> <span class="n">verify</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_mixture</span><span class="p">(</span><span class="n">dest</span><span class="p">),</span>
            <span class="s1">&#39;&quot;</span><span class="si">{}</span><span class="s1">&quot; does not define a valid mixture&#39;</span><span class="p">,</span>
            <span class="n">mixture</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">dest</span>

    <span class="k">def</span> <span class="nf">_to_arr_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert array to json&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">role</span><span class="p">:</span> <span class="p">{</span><span class="n">strat</span><span class="p">:</span> <span class="n">val</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">strat</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">strats</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">values</span><span class="p">,</span> <span class="n">role</span><span class="p">,</span> <span class="n">strats</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strat_names</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">values</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">mixture_to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a mixture array to json&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_arr_json</span><span class="p">(</span><span class="n">mixture</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_from_arr_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr_str</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">parse</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read an array from a string&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
                <span class="n">dest</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span>
                <span class="s2">&quot;dest dtype doesn&#39;t match specified dtype&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
                <span class="n">dest</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,),</span> <span class="s2">&quot;dest shape must be num strats&quot;</span>
            <span class="p">)</span>
        <span class="n">dest</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">role_str</span> <span class="ow">in</span> <span class="n">arr_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">):</span>
            <span class="n">role</span><span class="p">,</span> <span class="n">strats</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">role_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">sstrat</span> <span class="ow">in</span> <span class="n">strats</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">):</span>
                <span class="n">val</span><span class="p">,</span> <span class="n">strat</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sstrat</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">dest</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">role_strat_index</span><span class="p">(</span><span class="n">role</span><span class="p">,</span> <span class="n">strat</span><span class="p">)]</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dest</span>

    <span class="k">def</span> <span class="nf">mixture_from_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mix_str</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a mixture from it&#39;s repr&quot;&quot;&quot;</span>
        <span class="n">mixture</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_arr_repr</span><span class="p">(</span><span class="n">mix_str</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">_parse_percent</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
            <span class="ow">not</span> <span class="n">verify</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_mixture</span><span class="p">(</span><span class="n">mixture</span><span class="p">),</span>
            <span class="s1">&#39;&quot;</span><span class="si">{}</span><span class="s1">&quot; is not a valid mixture&#39;</span><span class="p">,</span>
            <span class="n">mix_str</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">mixture</span>

    <span class="k">def</span> <span class="nf">_to_arr_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">fmt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert an array to a string&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">role</span><span class="p">,</span>
                <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="s2">&quot;{:</span><span class="si">{}</span><span class="s2">} </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">strat</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">strat</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">strats</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">role</span><span class="p">,</span> <span class="n">strats</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strat_names</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">mixture_to_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a mixture to a string&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_arr_repr</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trim_mixture_precision</span><span class="p">(</span><span class="n">mixture</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">),</span> <span class="s2">&quot;.2%&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_from_arr_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr_str</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">parse</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get array from string representation&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
                <span class="n">dest</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span>
                <span class="s2">&quot;dest dtype must be the same type as specified&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
                <span class="n">dest</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,),</span> <span class="s2">&quot;dest shape must be num strats&quot;</span>
            <span class="p">)</span>
        <span class="n">dest</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">role</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">arr_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot; &quot;</span><span class="p">:</span>
                <span class="n">role</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">strat</span><span class="p">,</span> <span class="n">val_str</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">dest</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">role_strat_index</span><span class="p">(</span><span class="n">role</span><span class="p">,</span> <span class="n">strat</span><span class="p">)]</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">val_str</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dest</span>

    <span class="k">def</span> <span class="nf">mixture_from_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mix_str</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a mixture from a verbose string&quot;&quot;&quot;</span>
        <span class="n">mixture</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_arr_str</span><span class="p">(</span><span class="n">mix_str</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">_parse_percent</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
            <span class="ow">not</span> <span class="n">verify</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_mixture</span><span class="p">(</span><span class="n">mixture</span><span class="p">),</span>
            <span class="s1">&#39;&quot;</span><span class="si">{}</span><span class="s1">&quot; is not a valid mixture&#39;</span><span class="p">,</span>
            <span class="n">mix_str</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">mixture</span>

    <span class="k">def</span> <span class="nf">_to_arr_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">fmt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert an array to a printable string&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">role</span><span class="p">,</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="s2">&quot;    </span><span class="si">{}</span><span class="s2">: {:</span><span class="si">{}</span><span class="s2">}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">fmt</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">strats</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">probs</span><span class="p">,</span> <span class="n">role</span><span class="p">,</span> <span class="n">strats</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strat_names</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">mixture_to_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a mixture to a printable string&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_arr_str</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trim_mixture_precision</span><span class="p">(</span><span class="n">mixture</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">),</span> <span class="s2">&quot;&gt;7.2%&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">restriction_from_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jrest</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a restriction from json</span>

<span class="sd">        Json format is {role: [strat]}&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">dest</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;dest dtype must be boolean&quot;</span><span class="p">)</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
                <span class="n">dest</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,),</span> <span class="s2">&quot;dest shape must be num strats&quot;</span>
            <span class="p">)</span>
        <span class="n">dest</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">role</span><span class="p">,</span> <span class="n">strats</span> <span class="ow">in</span> <span class="n">jrest</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">strat</span> <span class="ow">in</span> <span class="n">strats</span><span class="p">:</span>
                <span class="n">dest</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">role_strat_index</span><span class="p">(</span><span class="n">role</span><span class="p">,</span> <span class="n">strat</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
            <span class="ow">not</span> <span class="n">verify</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_restriction</span><span class="p">(</span><span class="n">dest</span><span class="p">),</span>
            <span class="s1">&#39;&quot;</span><span class="si">{}</span><span class="s1">&quot; does not define a valid restriction&#39;</span><span class="p">,</span>
            <span class="n">jrest</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">dest</span>

    <span class="k">def</span> <span class="nf">restriction_to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rest</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a restriction to json&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">role</span><span class="p">:</span> <span class="p">[</span><span class="n">strat</span> <span class="k">for</span> <span class="n">strat</span><span class="p">,</span> <span class="n">inc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">strats</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="k">if</span> <span class="n">inc</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">mask</span><span class="p">,</span> <span class="n">role</span><span class="p">,</span> <span class="n">strats</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strat_names</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">restriction_from_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rrest</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a restriction from a repr string</span>

<span class="sd">        A restriction repr is &quot;role: strat, ...; ...&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">dest</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;dest dtype must be boolean&quot;</span><span class="p">)</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
                <span class="n">dest</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,),</span> <span class="s2">&quot;dest shape must be num strats&quot;</span>
            <span class="p">)</span>
        <span class="n">dest</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">role_str</span> <span class="ow">in</span> <span class="n">rrest</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">):</span>
            <span class="n">role</span><span class="p">,</span> <span class="n">strats</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">role_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">strat</span> <span class="ow">in</span> <span class="n">strats</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">):</span>
                <span class="n">dest</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">role_strat_index</span><span class="p">(</span><span class="n">role</span><span class="p">,</span> <span class="n">strat</span><span class="o">.</span><span class="n">strip</span><span class="p">())]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
            <span class="ow">not</span> <span class="n">verify</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_restriction</span><span class="p">(</span><span class="n">dest</span><span class="p">),</span>
            <span class="s1">&#39;&quot;</span><span class="si">{}</span><span class="s1">&quot; does not define a valid restriction&#39;</span><span class="p">,</span>
            <span class="n">rrest</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">dest</span>

    <span class="k">def</span> <span class="nf">restriction_to_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rest</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a restriction to a repr string&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">role</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">strat</span> <span class="k">for</span> <span class="n">strat</span><span class="p">,</span> <span class="n">inc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">strats</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="k">if</span> <span class="n">inc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">role</span><span class="p">,</span> <span class="n">strats</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strat_names</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">restriction_from_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">srest</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a restriction from a string&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">dest</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;dest dtype must be boolean&quot;</span><span class="p">)</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
                <span class="n">dest</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,),</span> <span class="s2">&quot;dest shape must be num strats&quot;</span>
            <span class="p">)</span>
        <span class="n">dest</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">role</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">srest</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot; &quot;</span><span class="p">:</span>
                <span class="n">role</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dest</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">role_strat_index</span><span class="p">(</span><span class="n">role</span><span class="p">,</span> <span class="n">line</span><span class="p">[</span><span class="mi">4</span><span class="p">:])]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
            <span class="ow">not</span> <span class="n">verify</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_restriction</span><span class="p">(</span><span class="n">dest</span><span class="p">),</span>
            <span class="s1">&#39;&quot;</span><span class="si">{}</span><span class="s1">&quot; does not define a valid restriction&#39;</span><span class="p">,</span>
            <span class="n">srest</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">dest</span>

    <span class="k">def</span> <span class="nf">restriction_to_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rest</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a restriction to a string&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">role</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;    </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">strats</span><span class="p">)</span> <span class="k">if</span> <span class="n">m</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">mask</span><span class="p">,</span> <span class="n">role</span><span class="p">,</span> <span class="n">strats</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rest</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strat_names</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">role_from_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">role_json</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read role array from json&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
                <span class="n">dest</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="s2">&quot;dest dtype must match dtype&quot;</span>
            <span class="p">)</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
                <span class="n">dest</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span><span class="p">,),</span> <span class="s2">&quot;dest shape must be num strats&quot;</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">role</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">role_json</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">dest</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">role_index</span><span class="p">(</span><span class="n">role</span><span class="p">)]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">dest</span>

    <span class="k">def</span> <span class="nf">role_to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">role_info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Format role data as json&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">role</span><span class="p">:</span> <span class="n">info</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">role</span><span class="p">,</span> <span class="n">info</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">role_info</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">info</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">role_to_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">role_info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Format role data as repr&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">role</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">role</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span> <span class="n">role_info</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">role_from_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rrole</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read role data from repr</span>

<span class="sd">        A role repr is `role:info` delimited by commas or semicolons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
                <span class="n">dest</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="s2">&quot;dest dtype must match dtype&quot;</span>
            <span class="p">)</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
                <span class="n">dest</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span><span class="p">,),</span> <span class="s2">&quot;dest shape must be num strats&quot;</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">rinfo</span> <span class="ow">in</span> <span class="n">rrole</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">):</span>
            <span class="n">role</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">rinfo</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">dest</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">role_index</span><span class="p">(</span><span class="n">role</span><span class="p">)]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">dest</span>

    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strat_names</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">num_roles</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_names</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">role_names</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">strat_names</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">strat_names</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">_GameLike</span><span class="p">(</span><span class="n">_StratArray</span><span class="p">):</span>  <span class="c1"># pylint: disable=too-many-public-methods</span>
    <span class="sd">&quot;&quot;&quot;Role-symmetric game representation</span>

<span class="sd">    This object only contains methods and information about definition of the</span>
<span class="sd">    game, without defining how payoff data is generated / accessed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    role_names : (str,)</span>
<span class="sd">        The name of each role.</span>
<span class="sd">    strat_names : ((str,),)</span>
<span class="sd">        The name of each strategy for each role.</span>
<span class="sd">    num_role_players :  ndarray</span>
<span class="sd">        The number of players in each role. Must contain non-negative integers.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">role_names</span><span class="p">,</span> <span class="n">strat_names</span><span class="p">,</span> <span class="n">num_role_players</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">role_names</span><span class="p">,</span> <span class="n">strat_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span> <span class="o">=</span> <span class="n">num_role_players</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_players</span> <span class="o">=</span> <span class="n">num_role_players</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">num_all_role_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of profiles in each role (independent of others)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">game_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">num_all_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The total number of profiles in the game</span>

<span class="sd">        Not just the ones with data.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_all_role_profiles</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">num_all_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of payoffs in all profiles&quot;&quot;&quot;</span>
        <span class="n">dev_players</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">game_size</span><span class="p">(</span><span class="n">dev_players</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">num_all_dpr_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of unique dpr profiles</span>

<span class="sd">        This calculation takes time exponential in the number of roles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get all combinations of &quot;pure&quot; roles and then filter by ones with</span>
        <span class="c1"># support at least 2. Thus, 0, 1, and 2 can be safely ignored</span>
        <span class="n">pure</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span><span class="p">))</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">cards</span> <span class="o">=</span> <span class="n">pure</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pure</span> <span class="o">=</span> <span class="n">pure</span><span class="p">[</span><span class="n">cards</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">cards</span> <span class="o">=</span> <span class="n">cards</span><span class="p">[</span><span class="n">cards</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># For each combination of pure roles, compute the number of profiles</span>
        <span class="c1"># conditioned on those roles being pure, then multiply them by the</span>
        <span class="c1"># cardinality of the pure roles.</span>
        <span class="n">pure_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span> <span class="o">*</span> <span class="n">pure</span> <span class="o">+</span> <span class="o">~</span><span class="n">pure</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">unpure_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">utils</span><span class="o">.</span><span class="n">game_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">)</span>
                <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span>
            <span class="p">)</span>
            <span class="o">*</span> <span class="o">~</span><span class="n">pure</span>
            <span class="o">+</span> <span class="n">pure</span><span class="p">,</span>
            <span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">overcount</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cards</span> <span class="o">*</span> <span class="n">pure_counts</span> <span class="o">*</span> <span class="n">unpure_counts</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_all_payoffs</span> <span class="o">-</span> <span class="n">overcount</span>

    <span class="nd">@property</span>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">_prof_id_base</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Base for profile ids&quot;&quot;&quot;</span>
        <span class="c1"># Base is reversed so that profile_ids are ascending</span>
        <span class="n">rprofs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_all_role_profiles</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_all_profiles</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
            <span class="n">rprofs</span> <span class="o">=</span> <span class="n">rprofs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">rprofs</span><span class="p">[:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">cumprod</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">_id_play</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ids for players&quot;&quot;&quot;</span>
        <span class="n">rev</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">rev</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span>
        <span class="k">return</span> <span class="n">rev</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">profile_to_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profiles</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a unique integer representing a profile&quot;&quot;&quot;</span>
        <span class="n">profiles</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">profiles</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">profiles</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span>
        <span class="n">profiles</span> <span class="o">=</span> <span class="n">profiles</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">game_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id_play</span><span class="p">,</span> <span class="n">profiles</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_all_profiles</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
            <span class="n">sizes</span> <span class="o">=</span> <span class="n">sizes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_prof_id_base</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">profile_from_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a profile from its integer representation&quot;&quot;&quot;</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
        <span class="n">role_ids</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prof_id_base</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_all_role_profiles</span>
        <span class="n">dec_profs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ids</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="n">role_ids_iter</span> <span class="o">=</span> <span class="n">role_ids</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
        <span class="n">role_ids_iter</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span><span class="p">)</span>
        <span class="n">dec_profs_iter</span> <span class="o">=</span> <span class="n">dec_profs</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
        <span class="n">dec_profs_iter</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">)</span>

        <span class="c1"># This can&#39;t be vectorized further, because the sizes are dependent</span>
        <span class="k">for</span> <span class="n">sizes</span><span class="p">,</span> <span class="n">profs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">role_ids_iter</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dec_profs_iter</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="p">):</span>
            <span class="k">for</span> <span class="n">prof</span><span class="p">,</span> <span class="n">rem</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">profs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">range</span><span class="p">(</span><span class="n">profs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">prof</span><span class="p">,</span> <span class="n">utils</span><span class="o">.</span><span class="n">game_size_inv</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">rem</span><span class="p">))</span>
                <span class="n">sizes</span> <span class="o">-=</span> <span class="n">utils</span><span class="o">.</span><span class="n">game_size</span><span class="p">(</span><span class="n">rem</span><span class="p">,</span> <span class="n">prof</span><span class="p">)</span>
        <span class="n">profiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dec_profs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">profiles</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">]</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">profiles</span>

    <span class="k">def</span> <span class="nf">is_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prof</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Verify that a profile is valid for game&quot;&quot;&quot;</span>
        <span class="n">prof</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">prof</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
            <span class="n">prof</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,</span> <span class="s2">&quot;profiles must have valid shape&quot;</span>
        <span class="p">)</span>
        <span class="n">play_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">prof</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">play_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">play_shape</span><span class="p">)</span>
            <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">prof</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span>
            <span class="n">axis</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">prof</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_pure_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prof</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Verify a profile is pure&quot;&quot;&quot;</span>
        <span class="n">prof</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">prof</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_profile</span><span class="p">(</span><span class="n">prof</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pure_restriction</span><span class="p">(</span>
            <span class="n">prof</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">all_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all profiles&quot;&quot;&quot;</span>
        <span class="n">role_arrays</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">acomb</span><span class="p">(</span><span class="n">n_strats</span><span class="p">,</span> <span class="n">players</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n_strats</span><span class="p">,</span> <span class="n">players</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">acartesian2</span><span class="p">(</span><span class="o">*</span><span class="n">role_arrays</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pure_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all pure profiles</span>

<span class="sd">        A pure profile is a profile where only one strategy is played per</span>
<span class="sd">        role.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pure_restrictions</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">nearby_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profile</span><span class="p">,</span> <span class="n">num_devs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns profiles reachable by at most num_devs deviations&quot;&quot;&quot;</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">num_devs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;num devs must be nonnegative&quot;</span><span class="p">)</span>
        <span class="n">profile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">dev_players</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">acomb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span><span class="p">,</span> <span class="n">num_devs</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dev_players</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dev_players</span> <span class="o">=</span> <span class="n">dev_players</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">supp</span> <span class="o">=</span> <span class="n">profile</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">sub_strats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">supp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">)</span>

        <span class="n">profiles</span> <span class="o">=</span> <span class="p">[</span><span class="n">profile</span><span class="p">[</span><span class="kc">None</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">players</span> <span class="ow">in</span> <span class="n">dev_players</span><span class="p">:</span>
            <span class="n">to_dev_profs</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">players</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">)</span><span class="o">.</span><span class="n">all_profiles</span><span class="p">()</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">players</span><span class="p">,</span> <span class="n">sub_strats</span><span class="p">)</span>
            <span class="n">from_dev_profs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sub</span><span class="o">.</span><span class="n">num_all_profiles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
            <span class="n">from_dev_profs</span><span class="p">[:,</span> <span class="n">supp</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">all_profiles</span><span class="p">()</span>
            <span class="n">before_devs</span> <span class="o">=</span> <span class="n">profile</span> <span class="o">-</span> <span class="n">from_dev_profs</span>
            <span class="n">before_devs</span> <span class="o">=</span> <span class="n">before_devs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">before_devs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="n">before_devs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">axis_from_elem</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">axis_to_elem</span><span class="p">(</span><span class="n">before_devs</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">nearby</span> <span class="o">=</span> <span class="n">before_devs</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">to_dev_profs</span>
            <span class="n">nearby</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">)</span>
            <span class="n">profiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">axis_from_elem</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">axis_to_elem</span><span class="p">(</span><span class="n">nearby</span><span class="p">))))</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">axis_from_elem</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">axis_to_elem</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">profiles</span><span class="p">)))</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">random_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a random profile&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_profiles</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">mixture</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">random_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">mixture</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sample profiles from a mixture</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        num_samples : int</span>
<span class="sd">            Number of samples to return.</span>
<span class="sd">        mixture : ndarray, optional</span>
<span class="sd">            Mixture to sample from, of None or omitted, then uses the uniform</span>
<span class="sd">            mixture.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mixture</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mixture</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniform_mixture</span><span class="p">()</span>
        <span class="n">role_samples</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">rand</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">probs</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">probs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">mixture</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="p">)</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">role_samples</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">round_mixture_to_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Round a mixture to the nearest profile</span>

<span class="sd">        This finds the profile with the minimum absolute error to the product</span>
<span class="sd">        of the profile and the number of players per role.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">float_prof</span> <span class="o">=</span> <span class="n">mixture</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">)</span>
        <span class="n">profile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">float_prof</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">profile</span>
            <span class="o">-</span> <span class="n">float_prof</span>
            <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">)</span>
        <span class="n">profile</span><span class="p">[</span><span class="n">rank</span> <span class="o">&lt;</span> <span class="n">missing</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">profile</span>

    <span class="k">def</span> <span class="nf">random_role_deviation_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a random role deviation profile&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_role_deviation_profiles</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">mixture</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">random_role_deviation_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">mixture</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return partial profiles where dev player is missing</span>

<span class="sd">        Resulting shape of profiles is (num_samples, num_roles,</span>
<span class="sd">        num_role_strats). The first dimension is the sample, the next is the</span>
<span class="sd">        deviating role, leaving the last dimension for the partial profile.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mixture : ndarray</span>
<span class="sd">            Mixture to sample from.</span>
<span class="sd">        num_samples : int, optional</span>
<span class="sd">            Number of samples to return. If None or omitted, then a single</span>
<span class="sd">            sample, without a leading singleton dimension is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mixture</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mixture</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniform_mixture</span><span class="p">()</span>
        <span class="n">dev_players</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">profs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">players</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dev_players</span><span class="p">):</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">players</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">)</span>
            <span class="n">profs</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">random_profiles</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">mixture</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">profs</span>

    <span class="k">def</span> <span class="nf">random_deviation_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a random deviation profile&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_deviation_profiles</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">mixture</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">random_deviation_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">mixture</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a profiles where one player is deviating from mix</span>

<span class="sd">        Resulting shape of profiles is (num_samples, num_role_strats,</span>
<span class="sd">        num_role_strats). The first dimension is the sample, the next is the</span>
<span class="sd">        deviating strategy, leaving the last dimension for the actual</span>
<span class="sd">        profile.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mixture : ndarray</span>
<span class="sd">            Mixture to sample from.</span>
<span class="sd">        num_samples : int, optional</span>
<span class="sd">            Number of samples to return. If None or omitted, then a single</span>
<span class="sd">            sample, without a leading singleton dimension is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">devs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_role_deviation_profiles</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">mixture</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">devs</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">max_prob_prof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the pure strategy profile with highest probability.&quot;&quot;&quot;</span>
        <span class="n">mixture</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mixture</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">utils</span><span class="o">.</span><span class="n">multinomial_mode</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">mixture</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span>
                <span class="p">)</span>
            <span class="p">],</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">is_symmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns true if this game is symmetric&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">is_asymmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns true if this game is asymmetric&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">profile_from_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prof</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a profile from json</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        prof : {role: {strat: count}}</span>
<span class="sd">            A description of a profile.</span>
<span class="sd">        dest : ndarray, optional</span>
<span class="sd">            If supplied, ``dest`` will be written to instead of allocating a</span>
<span class="sd">            new array.</span>
<span class="sd">        verify : bool, optional</span>
<span class="sd">            If true, verify that a proepr profile for this game was read.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">dest</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;dest dtype must be integral&quot;</span><span class="p">)</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
                <span class="n">dest</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,),</span> <span class="s2">&quot;dest shape must be num strats&quot;</span>
            <span class="p">)</span>
        <span class="n">dest</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">role</span><span class="p">,</span> <span class="n">strats</span> <span class="ow">in</span> <span class="n">prof</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">strat</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">strats</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">dest</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">role_strat_index</span><span class="p">(</span><span class="n">role</span><span class="p">,</span> <span class="n">strat</span><span class="p">)]</span> <span class="o">=</span> <span class="n">count</span>

        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
            <span class="ow">not</span> <span class="n">verify</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_profile</span><span class="p">(</span><span class="n">dest</span><span class="p">),</span> <span class="s1">&#39;&quot;</span><span class="si">{}</span><span class="s1">&quot; is not a valid profile&#39;</span><span class="p">,</span> <span class="n">prof</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">dest</span>

    <span class="k">def</span> <span class="nf">payoff_from_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pays</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a payoff from json</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pays : {role: {strat: payoff}}</span>
<span class="sd">            A description of a payoff.</span>
<span class="sd">        dest : ndarray, optional</span>
<span class="sd">            If supplied, ``dest`` will be written to instead of allocating a</span>
<span class="sd">            new array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">dest</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="s2">&quot;dest dtype must be floating&quot;</span><span class="p">)</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
                <span class="n">dest</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,),</span> <span class="s2">&quot;dest shape must be num strats&quot;</span>
            <span class="p">)</span>
        <span class="n">dest</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">role</span><span class="p">,</span> <span class="n">strats</span> <span class="ow">in</span> <span class="n">pays</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">strat</span><span class="p">,</span> <span class="n">pay</span> <span class="ow">in</span> <span class="n">strats</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">dest</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">role_strat_index</span><span class="p">(</span><span class="n">role</span><span class="p">,</span> <span class="n">strat</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_mean</span><span class="p">(</span><span class="n">pay</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dest</span>

    <span class="k">def</span> <span class="nf">profile_to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prof</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a profile array to json&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_arr_json</span><span class="p">(</span><span class="n">prof</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">payoff_to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">payoffs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Format payoffs as json</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        payoffs : ndarray</span>
<span class="sd">            The payoffs to serialize.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_arr_json</span><span class="p">(</span><span class="n">payoffs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">profile_from_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prof_str</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a profile from a string&quot;&quot;&quot;</span>
        <span class="n">prof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_arr_repr</span><span class="p">(</span><span class="n">prof_str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
            <span class="ow">not</span> <span class="n">verify</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_profile</span><span class="p">(</span><span class="n">prof</span><span class="p">),</span>
            <span class="s1">&#39;&quot;</span><span class="si">{}</span><span class="s1">&quot; does not define a profile&#39;</span><span class="p">,</span>
            <span class="n">prof_str</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">prof</span>

    <span class="k">def</span> <span class="nf">profile_to_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prof</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a profile to a string&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_arr_repr</span><span class="p">(</span><span class="n">prof</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">profile_from_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prof_str</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get profile from string&quot;&quot;&quot;</span>
        <span class="n">prof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_arr_str</span><span class="p">(</span><span class="n">prof_str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
            <span class="ow">not</span> <span class="n">verify</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_profile</span><span class="p">(</span><span class="n">prof</span><span class="p">),</span> <span class="s1">&#39;&quot;</span><span class="si">{}</span><span class="s1">&quot; is not a valid profile&#39;</span><span class="p">,</span> <span class="n">prof_str</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">prof</span>

    <span class="k">def</span> <span class="nf">profile_to_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prof</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a profile to a printable string&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_arr_str</span><span class="p">(</span><span class="n">prof</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">devpay_from_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deviations</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get deviation payoffs from json&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_devs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">dest</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="s2">&quot;dest dtype must be floating&quot;</span><span class="p">)</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">dest</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_devs</span><span class="p">,),</span> <span class="s2">&quot;dest shape must be num strats&quot;</span><span class="p">)</span>
        <span class="n">dest</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">role</span><span class="p">,</span> <span class="n">strats</span> <span class="ow">in</span> <span class="n">deviations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">strat</span><span class="p">,</span> <span class="n">devs</span> <span class="ow">in</span> <span class="n">strats</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">dev</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">devs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">dest</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">role_strat_dev_index</span><span class="p">(</span><span class="n">role</span><span class="p">,</span> <span class="n">strat</span><span class="p">,</span> <span class="n">dev</span><span class="p">)]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="k">return</span> <span class="n">dest</span>

    <span class="k">def</span> <span class="nf">devpay_to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">payoffs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Format a profile and deviation payoffs as json&quot;&quot;&quot;</span>
        <span class="n">payoffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">payoffs</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">r</span><span class="p">:</span> <span class="p">{</span>
                <span class="n">s</span><span class="p">:</span> <span class="p">{</span>
                    <span class="n">d</span><span class="p">:</span> <span class="n">pay</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">pay</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spays</span><span class="p">,</span> <span class="n">ses</span><span class="p">)</span>  <span class="c1"># pragma: no branch</span>
                    <span class="k">if</span> <span class="n">pay</span> <span class="o">!=</span> <span class="mi">0</span>
                <span class="p">}</span>
                <span class="k">for</span> <span class="n">spays</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">rpay</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">ses</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">spays</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">ses</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">rpay</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strat_names</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">payoffs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dev_role_starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rpay</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Format game as json&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;players&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span><span class="p">))),</span>
            <span class="s2">&quot;strategies&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strat_names</span><span class="p">))),</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Format game as a printable string&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">    Roles: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">    Players:</span><span class="se">\n</span><span class="s2">        </span><span class="si">{}</span><span class="se">\n</span><span class="s2">    &quot;</span>
            <span class="s2">&quot;Strategies:</span><span class="se">\n</span><span class="s2">        </span><span class="si">{}</span><span class="s2">&quot;</span>
        <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
            <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">),</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">        &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{:d}</span><span class="s2">x </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">role</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">role</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">        &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">            </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">role</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">            &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">strats</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">role</span><span class="p">,</span> <span class="n">strats</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strat_names</span><span class="p">)</span>
            <span class="p">),</span>
        <span class="p">)</span>

    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()))</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">num_role_players</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">_RsGame</span><span class="p">(</span><span class="n">_GameLike</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Role-symmetric game representation</span>

<span class="sd">    This object only contains methods and information about definition of the</span>
<span class="sd">    game, without defining how payoff data is generated / accessed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    role_names : (str,)</span>
<span class="sd">        The name of each role.</span>
<span class="sd">    strat_names : ((str,),)</span>
<span class="sd">        The name of each strategy for each role.</span>
<span class="sd">    num_role_players :  ndarray</span>
<span class="sd">        The number of players in each role. Must contain non-negative integers.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">role_names</span><span class="p">,</span> <span class="n">strat_names</span><span class="p">,</span> <span class="n">num_role_players</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">role_names</span><span class="p">,</span> <span class="n">strat_names</span><span class="p">,</span> <span class="n">num_role_players</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zero_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zero_prob</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># ----------------</span>
    <span class="c1"># Abstract Methods</span>
    <span class="c1"># ----------------</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">num_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of profiles with any payoff information&quot;&quot;&quot;</span>
        <span class="k">pass</span>  <span class="c1"># pragma: no cover</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">num_complete_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of profiles with complete payoff information&quot;&quot;&quot;</span>
        <span class="k">pass</span>  <span class="c1"># pragma: no cover</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An array all of the profiles with any data&quot;&quot;&quot;</span>
        <span class="k">pass</span>  <span class="c1"># pragma: no cover</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An array with all of the payoff corresponding to profiles()&quot;&quot;&quot;</span>
        <span class="k">pass</span>  <span class="c1"># pragma: no cover</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">max_strat_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An upper bound on the payoff for each strategy&quot;&quot;&quot;</span>
        <span class="k">pass</span>  <span class="c1"># pragma: no cover</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">min_strat_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A lower bound on the payoff for each strategy&quot;&quot;&quot;</span>
        <span class="k">pass</span>  <span class="c1"># pragma: no cover</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profiles</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The payoffs for all profiles&quot;&quot;&quot;</span>
        <span class="k">pass</span>  <span class="c1"># pragma: no cover</span>

    <span class="c1"># Note: This should allow arbitrary keyword arguments which is ignores if</span>
    <span class="c1"># they&#39;re invalid.</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">deviation_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">jacobian</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The payoffs for deviating from mixture</span>

<span class="sd">        Optionally with the jacobian with respect to mixture. This is the</span>
<span class="sd">        primary method that needs to implemented for nash finding.&quot;&quot;&quot;</span>
        <span class="k">pass</span>  <span class="c1"># pragma: no cover</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">restrict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">restriction</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Restrict viable strategies&quot;&quot;&quot;</span>
        <span class="k">pass</span>  <span class="c1"># pragma: no cover</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if full payoff data for profile exists&quot;&quot;&quot;</span>
        <span class="k">pass</span>  <span class="c1"># pragma: no cover</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_add_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constant</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a constant to each roles payoffs&quot;&quot;&quot;</span>
        <span class="k">pass</span>  <span class="c1"># pragma: no cover</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_multiply_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constant</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiply each roles payoffs by a positive constant&quot;&quot;&quot;</span>
        <span class="k">pass</span>  <span class="c1"># pragma: no cover</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_add_game</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">othr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add two games together, so payoffs are the sum</span>

<span class="sd">        othr is guaranteed to be a game like object with the same structure as</span>
<span class="sd">        self. If no add can be done efficiently, then this should return</span>
<span class="sd">        NotImplemented.&quot;&quot;&quot;</span>
        <span class="k">pass</span>  <span class="c1"># pragma: no cover</span>

    <span class="c1"># --------------------</span>
    <span class="c1"># End Abstract Methods</span>
    <span class="c1"># --------------------</span>

    <span class="k">def</span> <span class="nf">min_role_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the minimum payoff for each role&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fmin</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_strat_payoffs</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">max_role_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the maximum payoff for each role&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fmax</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_strat_payoffs</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new game where the max payoff is 1 and min payoff is 0&quot;&quot;&quot;</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_role_payoffs</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_role_payoffs</span><span class="p">()</span>
        <span class="n">scale</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">scale</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_role_payoffs</span><span class="p">()</span>
        <span class="n">offset</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">offset</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span>

    <span class="k">def</span> <span class="nf">get_dev_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dev_profs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the payoffs for deviating</span>

<span class="sd">        Given partial profiles per role, compute the mean</span>
<span class="sd">        payoff for deviating to each strategy.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dev_profs : array-like, shape = (num_samples, num_roles, num_strats)</span>
<span class="sd">            A list of partial profiles by role. This is the same structure as</span>
<span class="sd">            returned by `random_dev_profiles`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_payoffs</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">dev_profs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns true if no profiles have data&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_profiles</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">is_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns true if every profile has data&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_complete_profiles</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_all_profiles</span>

    <span class="k">def</span> <span class="nf">is_constant_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns true if this game is constant sum&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">profile_sums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,ij-&gt;i&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiles</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">payoffs</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">profile_sums</span><span class="p">,</span> <span class="n">profile_sums</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">expected_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the payoff of each role under mixture&quot;&quot;&quot;</span>
        <span class="n">mixture</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mixture</span><span class="p">)</span>
        <span class="n">deviations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deviation_payoffs</span><span class="p">(</span><span class="n">mixture</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span>
            <span class="n">mixture</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mixture</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">deviations</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">best_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the best response to a mixture</span>

<span class="sd">        The result is a new mixture with uniform support over all best</span>
<span class="sd">        deviating strategies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">responses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deviation_payoffs</span><span class="p">(</span><span class="n">mixture</span><span class="p">)</span>
        <span class="n">bests</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">responses</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">)</span>
        <span class="n">best_resps</span> <span class="o">=</span> <span class="n">responses</span> <span class="o">==</span> <span class="n">bests</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>  <span class="c1"># nan</span>
            <span class="k">return</span> <span class="n">best_resps</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">best_resps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constant</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">constant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">constant</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">constant</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiply_constant</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constant</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constant</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">constant</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">othr</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">suppress</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_constant</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">othr</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">empty_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">empty_copy</span><span class="p">(</span><span class="n">othr</span><span class="p">)</span>
            <span class="n">attempt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_game</span><span class="p">(</span><span class="n">othr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">attempt</span> <span class="ow">is</span> <span class="bp">NotImplemented</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span>
                <span class="n">othr</span>
            <span class="p">):</span>  <span class="c1"># pylint: disable=no-else-return</span>
                <span class="k">return</span> <span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">othr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">attempt</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">othr</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">suppress</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_constant</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">othr</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">empty_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">empty_copy</span><span class="p">(</span><span class="n">othr</span><span class="p">)</span>
            <span class="n">attempt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_game</span><span class="p">(</span><span class="n">othr</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">othr</span><span class="p">)</span> <span class="k">if</span> <span class="n">attempt</span> <span class="ow">is</span> <span class="bp">NotImplemented</span> <span class="k">else</span> <span class="n">attempt</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">othr</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_constant</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">othr</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>


<span class="k">class</span> <span class="nc">_EmptyGame</span><span class="p">(</span><span class="n">_RsGame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A game with no payoff data&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">role_names</span><span class="p">,</span> <span class="n">strat_names</span><span class="p">,</span> <span class="n">num_role_players</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">role_names</span><span class="p">,</span> <span class="n">strat_names</span><span class="p">,</span> <span class="n">num_role_players</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_profiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_complete_profiles</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_profiles</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_complete_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_complete_profiles</span>

    <span class="k">def</span> <span class="nf">profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>

    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">max_strat_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">maxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">maxs</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">maxs</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>

    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">min_strat_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">mins</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mins</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profiles</span><span class="p">):</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_profile</span><span class="p">(</span><span class="n">profiles</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s2">&quot;profiles must be valid&quot;</span><span class="p">)</span>
        <span class="n">pays</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">profiles</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">pays</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">pays</span><span class="p">[</span><span class="n">profiles</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pays</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pays</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">deviation_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">jacobian</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">_</span><span class="p">):</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_mixture</span><span class="p">(</span><span class="n">mixture</span><span class="p">),</span> <span class="s2">&quot;mixtures must be valid&quot;</span><span class="p">)</span>
        <span class="n">devs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">jacobian</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">devs</span>

        <span class="n">jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">,)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">devs</span><span class="p">,</span> <span class="n">jac</span>

    <span class="k">def</span> <span class="nf">restrict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">restriction</span><span class="p">):</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_restriction</span><span class="p">(</span><span class="n">restriction</span><span class="p">),</span> <span class="s2">&quot;restrictions must be valid&quot;</span><span class="p">)</span>
        <span class="n">new_strats</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">strats</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="k">if</span> <span class="n">m</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">strats</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strat_names</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">restriction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">role_starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">_EmptyGame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span> <span class="n">new_strats</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_multiply_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_add_game</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profile</span><span class="p">):</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_profile</span><span class="p">(</span><span class="n">profile</span><span class="p">),</span> <span class="s2">&quot;profile must be valid&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">to_json</span><span class="p">()</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;empty.1&quot;</span>
        <span class="k">return</span> <span class="n">res</span>


<div class="viewcode-block" id="empty"><a class="viewcode-back" href="../../gameanalysis.rsgame.html#gameanalysis.rsgame.empty">[docs]</a><span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="n">num_role_players</span><span class="p">,</span> <span class="n">num_role_strats</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create an empty game with default names</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_role_players : ndarray-like, int</span>
<span class="sd">        The number of players in each role in order, or the number of players</span>
<span class="sd">        per role if identical (will be broadcast to match the number of roles).</span>
<span class="sd">    num_role_strats : ndarray-like, int</span>
<span class="sd">        The number of strategies in each role in order, or the number of</span>
<span class="sd">        strategies per role if identical (will be broadcast to match the number</span>
<span class="sd">        of roles).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_role_players</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">num_role_players</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="n">num_role_strats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">num_role_strats</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">num_role_players</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;can&#39;t have a negative number of players&quot;</span>
    <span class="p">)</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">num_role_strats</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;must have at least one strategy per role&quot;</span><span class="p">)</span>
    <span class="n">num_roles</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">num_role_players</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">num_role_strats</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">num_role_players</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">num_role_players</span><span class="p">,</span> <span class="n">num_roles</span><span class="p">)</span>
    <span class="n">num_role_strats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">num_role_strats</span><span class="p">,</span> <span class="n">num_roles</span><span class="p">)</span>
    <span class="n">role_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">prefix_strings</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">num_roles</span><span class="p">))</span>
    <span class="n">strats</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">prefix_strings</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="n">num_role_strats</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    <span class="n">strat_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="nb">tuple</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">strats</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">num_role_strats</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">_EmptyGame</span><span class="p">(</span><span class="n">role_names</span><span class="p">,</span> <span class="n">strat_names</span><span class="p">,</span> <span class="n">num_role_players</span><span class="p">)</span></div>


<div class="viewcode-block" id="empty_names"><a class="viewcode-back" href="../../gameanalysis.rsgame.html#gameanalysis.rsgame.empty_names">[docs]</a><span class="k">def</span> <span class="nf">empty_names</span><span class="p">(</span><span class="n">role_names</span><span class="p">,</span> <span class="n">num_role_players</span><span class="p">,</span> <span class="n">strat_names</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create an empty game with names</span>

<span class="sd">    PArameters</span>
<span class="sd">    ----------</span>
<span class="sd">    roles_names : [str]</span>
<span class="sd">        The name for each role.</span>
<span class="sd">    num_role_players : ndarray, int, [int]</span>
<span class="sd">        The number of players in each role.</span>
<span class="sd">    strat_names : [[str]]</span>
<span class="sd">        The name of each strategy for each role.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">role_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">strat_names</span><span class="p">),</span> <span class="s2">&quot;number of roles must be consistent&quot;</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">role</span> <span class="ow">in</span> <span class="n">role_names</span><span class="p">:</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">role</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;role </span><span class="si">{}</span><span class="s2"> is not a string&quot;</span><span class="p">,</span> <span class="n">role</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">strats</span> <span class="ow">in</span> <span class="n">strat_names</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">strat</span> <span class="ow">in</span> <span class="n">strats</span><span class="p">:</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">strat</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;strategy </span><span class="si">{}</span><span class="s2"> is not a string&quot;</span><span class="p">,</span> <span class="n">strat</span><span class="p">)</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">is_sorted</span><span class="p">(</span><span class="n">role_names</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="s2">&quot;role names must be sorted&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">strats</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">strat_names</span><span class="p">):</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">is_sorted</span><span class="p">(</span><span class="n">strats</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="s2">&quot;strategies in role </span><span class="si">{:d}</span><span class="s2"> must be sorted&quot;</span><span class="p">,</span>
            <span class="n">i</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">strats</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">strat_names</span><span class="p">):</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">strats</span><span class="p">,</span> <span class="s2">&quot;role </span><span class="si">{:d}</span><span class="s2"> must have at least one strategy&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">num_role_players</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">num_role_players</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">role_names</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="c1"># This test for equality because we get games with zero players when</span>
    <span class="c1"># deviating, in the same way that 1 strategy is technically degenerate</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">num_role_players</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;number of players must be non-negative&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">role</span> <span class="ow">in</span> <span class="n">role_names</span><span class="p">:</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
            <span class="n">_LEG_ROLE</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">role</span><span class="p">),</span> <span class="s2">&quot;role </span><span class="si">{}</span><span class="s2"> contains illegal characters&quot;</span><span class="p">,</span> <span class="n">role</span>
        <span class="p">)</span>
    <span class="k">for</span> <span class="n">strats</span> <span class="ow">in</span> <span class="n">strat_names</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">strat</span> <span class="ow">in</span> <span class="n">strats</span><span class="p">:</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
                <span class="n">_LEG_STRAT</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">strat</span><span class="p">),</span>
                <span class="s2">&quot;strategy </span><span class="si">{}</span><span class="s2"> contains illegal characters&quot;</span><span class="p">,</span>
                <span class="n">strat</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">_EmptyGame</span><span class="p">(</span>
        <span class="nb">tuple</span><span class="p">(</span><span class="n">role_names</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">strat_names</span><span class="p">)),</span> <span class="n">num_role_players</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="empty_json"><a class="viewcode-back" href="../../gameanalysis.rsgame.html#gameanalysis.rsgame.empty_json">[docs]</a><span class="k">def</span> <span class="nf">empty_json</span><span class="p">(</span><span class="n">json</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Read a EmptyGame from json</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    json : {...}</span>
<span class="sd">        A json representation of a basic game with names. Must either be</span>
<span class="sd">        {roles: [{name: &lt;role&gt;, strategies: [&lt;strat&gt;]}]}, or {strategies:</span>
<span class="sd">        {&lt;role&gt;: [&lt;strat&gt;]}}.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;roles&quot;</span> <span class="ow">in</span> <span class="n">json</span><span class="p">:</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="p">[(</span><span class="n">j</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">j</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">],</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="s2">&quot;strategies&quot;</span><span class="p">]))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">json</span><span class="p">[</span><span class="s2">&quot;roles&quot;</span><span class="p">]]</span>
    <span class="k">elif</span> <span class="p">{</span><span class="s2">&quot;strategies&quot;</span><span class="p">,</span> <span class="s2">&quot;players&quot;</span><span class="p">}</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">json</span><span class="p">):</span>
        <span class="n">players</span> <span class="o">=</span> <span class="n">json</span><span class="p">[</span><span class="s2">&quot;players&quot;</span><span class="p">]</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="p">[(</span><span class="n">r</span><span class="p">,</span> <span class="n">players</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">json</span><span class="p">[</span><span class="s2">&quot;strategies&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;&quot;</span><span class="si">{}</span><span class="s1">&quot; does not describe a game&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">json</span><span class="p">))</span>
    <span class="n">desc</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">role_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">desc</span><span class="p">)</span>
    <span class="n">strat_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">desc</span><span class="p">)</span>
    <span class="n">num_role_players</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
        <span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">desc</span><span class="p">),</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
    <span class="p">)</span>  <span class="c1"># pragma: no branch pylint: disable=line-too-long</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
        <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">role_names</span><span class="p">),</span> <span class="s2">&quot;role names must be strings&quot;</span>
    <span class="p">)</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
        <span class="nb">all</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strats</span><span class="p">)</span> <span class="k">for</span> <span class="n">strats</span> <span class="ow">in</span> <span class="n">strat_names</span><span class="p">),</span>
        <span class="s2">&quot;strategy names must be strings&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
        <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strat_names</span><span class="p">),</span> <span class="s2">&quot;must have at least one strategy per role&quot;</span>
    <span class="p">)</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">num_role_players</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;number of players must be non-negative&quot;</span><span class="p">)</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
        <span class="nb">all</span><span class="p">(</span><span class="n">_LEG_ROLE</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">role_names</span><span class="p">),</span> <span class="s2">&quot;role names must be valid&quot;</span>
    <span class="p">)</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
        <span class="nb">all</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">_LEG_STRAT</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strats</span><span class="p">)</span> <span class="k">for</span> <span class="n">strats</span> <span class="ow">in</span> <span class="n">strat_names</span><span class="p">),</span>
        <span class="s2">&quot;strat names must be valid&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">_EmptyGame</span><span class="p">(</span><span class="n">role_names</span><span class="p">,</span> <span class="n">strat_names</span><span class="p">,</span> <span class="n">num_role_players</span><span class="p">)</span></div>


<div class="viewcode-block" id="empty_copy"><a class="viewcode-back" href="../../gameanalysis.rsgame.html#gameanalysis.rsgame.empty_copy">[docs]</a><span class="k">def</span> <span class="nf">empty_copy</span><span class="p">(</span><span class="n">copy_game</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Copy parameters of a game into an empty game</span>

<span class="sd">    This method is useful to keep convenience methods of game without attached</span>
<span class="sd">    data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    copy_game : RsGame</span>
<span class="sd">        Game to copy info from.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_EmptyGame</span><span class="p">(</span>
        <span class="n">copy_game</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span> <span class="n">copy_game</span><span class="o">.</span><span class="n">strat_names</span><span class="p">,</span> <span class="n">copy_game</span><span class="o">.</span><span class="n">num_role_players</span>
    <span class="p">)</span></div>


<span class="k">class</span> <span class="nc">_AddGame</span><span class="p">(</span><span class="n">_RsGame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A Game representing the addition of two games</span>

<span class="sd">    Payoffs in this game are the sum of the payoffs from each game. Some game</span>
<span class="sd">    types may support native addition, this is the fallback.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">games</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">games</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span> <span class="n">games</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strat_names</span><span class="p">,</span> <span class="n">games</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_role_players</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_games</span> <span class="o">=</span> <span class="n">games</span>

    <span class="nd">@property</span>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">num_complete_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span> <span class="k">for</span> <span class="n">game</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_games</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_all_profiles</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span>
            <span class="nb">frozenset</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
                <span class="o">*</span><span class="p">[</span>
                    <span class="nb">frozenset</span><span class="p">(</span>
                        <span class="n">utils</span><span class="o">.</span><span class="n">hash_array</span><span class="p">(</span><span class="n">prof</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">prof</span><span class="p">,</span> <span class="n">pay</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">profiles</span><span class="p">(),</span> <span class="n">game</span><span class="o">.</span><span class="n">payoffs</span><span class="p">())</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pay</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">game</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_games</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">num_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">game</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span> <span class="k">for</span> <span class="n">game</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_games</span>
        <span class="p">):</span>  <span class="c1"># pylint: disable=no-else-return</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_all_profiles</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiles</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span> <span class="k">for</span> <span class="n">game</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_games</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_profiles</span><span class="p">()</span>

        <span class="n">profs</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[</span>
                <span class="nb">frozenset</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">hash_array</span><span class="p">(</span><span class="n">prof</span><span class="p">)</span> <span class="k">for</span> <span class="n">prof</span> <span class="ow">in</span> <span class="n">game</span><span class="o">.</span><span class="n">profiles</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">game</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_games</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">profs</span><span class="p">:</span>  <span class="c1"># pylint: disable=no-else-return</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">h</span><span class="o">.</span><span class="n">array</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">profs</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profiles</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">deviation_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mixture</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">jacobian</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">jacobian</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">deviation_payoffs</span><span class="p">(</span><span class="n">mix</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="k">for</span> <span class="n">game</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_games</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">map</span><span class="p">(</span>
            <span class="nb">sum</span><span class="p">,</span>
            <span class="nb">zip</span><span class="p">(</span>
                <span class="o">*</span><span class="p">[</span>
                    <span class="n">game</span><span class="o">.</span><span class="n">deviation_payoffs</span><span class="p">(</span><span class="n">mixture</span><span class="p">,</span> <span class="n">jacobian</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">game</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_games</span>
                <span class="p">]</span>
            <span class="p">),</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profiles</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">get_payoffs</span><span class="p">(</span><span class="n">profiles</span><span class="p">)</span> <span class="k">for</span> <span class="n">game</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_games</span><span class="p">)</span>

    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">max_strat_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">max_strat_payoffs</span><span class="p">()</span> <span class="k">for</span> <span class="n">game</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_games</span><span class="p">)</span>

    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="nf">min_strat_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">min_strat_payoffs</span><span class="p">()</span> <span class="k">for</span> <span class="n">game</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_games</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">restrict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">restriction</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_AddGame</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">restrict</span><span class="p">(</span><span class="n">restriction</span><span class="p">)</span> <span class="k">for</span> <span class="n">game</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_games</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_add_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constant</span><span class="p">):</span>
        <span class="n">avg_const</span> <span class="o">=</span> <span class="n">constant</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_games</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_AddGame</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">game</span> <span class="o">+</span> <span class="n">avg_const</span> <span class="k">for</span> <span class="n">game</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_games</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_multiply_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constant</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_AddGame</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">game</span> <span class="o">*</span> <span class="n">constant</span> <span class="k">for</span> <span class="n">game</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_games</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_add_game</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">othr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">othr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">base</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">to_json</span><span class="p">()</span>
        <span class="n">base</span><span class="p">[</span><span class="s2">&quot;games&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">game</span><span class="o">.</span><span class="n">to_json</span><span class="p">()</span> <span class="k">for</span> <span class="n">game</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_games</span><span class="p">]</span>
        <span class="n">base</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;add.1&quot;</span>
        <span class="k">return</span> <span class="n">base</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profile</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">profile</span> <span class="ow">in</span> <span class="n">game</span> <span class="k">for</span> <span class="n">game</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_games</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">othr</span><span class="p">):</span>
        <span class="c1"># pylint: disable-msg=protected-access</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">othr</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_games</span><span class="p">)</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">othr</span><span class="o">.</span><span class="n">_games</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_games</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">, </span><span class="si">{:d}</span><span class="s2"> / </span><span class="si">{:d}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_profiles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_all_profiles</span>
        <span class="p">)</span>


<div class="viewcode-block" id="add"><a class="viewcode-back" href="../../gameanalysis.rsgame.html#gameanalysis.rsgame.add">[docs]</a><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="o">*</span><span class="n">games</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add games together to that the payoff is the sum of each game</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    games : RsGame</span>
<span class="sd">        The games to add together</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">games</span><span class="p">,</span> <span class="s2">&quot;must add at least one game&quot;</span><span class="p">)</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">empty_copy</span><span class="p">(</span><span class="n">games</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
        <span class="nb">all</span><span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="n">empty_copy</span><span class="p">(</span><span class="n">game</span><span class="p">)</span> <span class="k">for</span> <span class="n">game</span> <span class="ow">in</span> <span class="n">games</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
        <span class="s2">&quot;all games must have same structure&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_games</span><span class="p">(</span><span class="n">game</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the games if it&#39;s an add game&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">game</span><span class="o">.</span><span class="n">_games</span>  <span class="c1"># pylint: disable=protected-access</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">game</span><span class="p">]</span>

    <span class="c1"># Expand games in base forms</span>
    <span class="n">games</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">get_games</span><span class="p">,</span> <span class="n">games</span><span class="p">)))</span>
    <span class="c1"># This attempts to add any game that can be added</span>
    <span class="n">final_games</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">games</span><span class="p">:</span>
        <span class="n">current_game</span> <span class="o">=</span> <span class="n">games</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">unmerged_games</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">game</span> <span class="ow">in</span> <span class="n">games</span><span class="p">:</span>
            <span class="c1"># pylint: disable-msg=protected-access</span>
            <span class="n">attempt</span> <span class="o">=</span> <span class="n">current_game</span><span class="o">.</span><span class="n">_add_game</span><span class="p">(</span><span class="n">game</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">attempt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">NotImplemented</span><span class="p">:</span>
                <span class="n">current_game</span> <span class="o">=</span> <span class="n">attempt</span>
                <span class="k">continue</span>
            <span class="n">attempt</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">_add_game</span><span class="p">(</span><span class="n">current_game</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">attempt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">NotImplemented</span><span class="p">:</span>
                <span class="n">current_game</span> <span class="o">=</span> <span class="n">attempt</span>
                <span class="k">continue</span>
            <span class="n">unmerged_games</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">game</span><span class="p">)</span>
        <span class="n">final_games</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_game</span><span class="p">)</span>
        <span class="n">games</span> <span class="o">=</span> <span class="n">unmerged_games</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_games</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># pylint: disable=no-else-return</span>
        <span class="k">return</span> <span class="n">final_games</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_AddGame</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">final_games</span><span class="p">))</span></div>


<div class="viewcode-block" id="add_json"><a class="viewcode-back" href="../../gameanalysis.rsgame.html#gameanalysis.rsgame.add_json">[docs]</a><span class="k">def</span> <span class="nf">add_json</span><span class="p">(</span><span class="n">jgame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Read added games from json&quot;&quot;&quot;</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">empty_json</span><span class="p">(</span><span class="n">jgame</span><span class="p">)</span>
    <span class="n">games</span> <span class="o">=</span> <span class="p">[</span><span class="n">gamereader</span><span class="o">.</span><span class="n">loadj</span><span class="p">(</span><span class="n">jg</span><span class="p">)</span> <span class="k">for</span> <span class="n">jg</span> <span class="ow">in</span> <span class="n">jgame</span><span class="p">[</span><span class="s2">&quot;games&quot;</span><span class="p">]]</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span>
        <span class="nb">all</span><span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="n">empty_copy</span><span class="p">(</span><span class="n">game</span><span class="p">)</span> <span class="k">for</span> <span class="n">game</span> <span class="ow">in</span> <span class="n">games</span><span class="p">),</span>
        <span class="s2">&quot;game structure didn&#39;t match each added game&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">games</span><span class="p">)</span></div>


<div class="viewcode-block" id="mix"><a class="viewcode-back" href="../../gameanalysis.rsgame.html#gameanalysis.rsgame.mix">[docs]</a><span class="k">def</span> <span class="nf">mix</span><span class="p">(</span><span class="n">game0</span><span class="p">,</span> <span class="n">game1</span><span class="p">,</span> <span class="n">prob</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mix games together</span>

<span class="sd">    The resulting payoff is a (1-prob) fraction of game0 and a prob fraction of</span>
<span class="sd">    game1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    game0 : RsGame</span>
<span class="sd">        The first game to mix.</span>
<span class="sd">    game1 : RsGame</span>
<span class="sd">        The second game to mix.</span>
<span class="sd">    prob : float</span>
<span class="sd">        The fraction to merge the games. 0 corresponds to a copy of `game0`, 1</span>
<span class="sd">        corresponds to `game1`, and somewhere between corresponds to the linear</span>
<span class="sd">        interpolation between them.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">prob</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;t must be in [0, 1] but was </span><span class="si">{:g}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">prob</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># pylint: disable=no-else-return</span>
        <span class="k">return</span> <span class="n">game0</span>
    <span class="k">elif</span> <span class="n">prob</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">game1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">prob</span><span class="p">)</span> <span class="o">*</span> <span class="n">game0</span> <span class="o">+</span> <span class="n">prob</span> <span class="o">*</span> <span class="n">game1</span></div>


<span class="k">class</span> <span class="nc">_CompleteGame</span><span class="p">(</span><span class="n">_RsGame</span><span class="p">):</span>  <span class="c1"># pylint: disable=abstract-method</span>
    <span class="sd">&quot;&quot;&quot;A game that defines everything for complete games</span>

<span class="sd">    Extend this if your game by default has payoff data for every profile.&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_all_profiles</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_complete_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_all_profiles</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_profiles</span><span class="p">()</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profiles</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profile</span><span class="p">):</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_profile</span><span class="p">(</span><span class="n">profile</span><span class="p">),</span> <span class="s2">&quot;profile must be valid&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">_ConstantGame</span><span class="p">(</span><span class="n">_CompleteGame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A game with constant payoffs&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">role_names</span><span class="p">,</span> <span class="n">strat_names</span><span class="p">,</span> <span class="n">num_role_players</span><span class="p">,</span> <span class="n">constant</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">role_names</span><span class="p">,</span> <span class="n">strat_names</span><span class="p">,</span> <span class="n">num_role_players</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_role_const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">constant</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_roles</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_role_const</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strat_const</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_role_const</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_role_strats</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strat_const</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deviation_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">jacobian</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">_kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">jacobian</span><span class="p">:</span>  <span class="c1"># pylint: disable=no-else-return</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strat_const</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">num_strats</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strat_const</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profiles</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">profiles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strat_const</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">max_strat_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strat_const</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">min_strat_payoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strat_const</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">restrict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">restriction</span><span class="p">):</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">empty_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">restrict</span><span class="p">(</span><span class="n">restriction</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_ConstantGame</span><span class="p">(</span>
            <span class="n">base</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">strat_names</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">num_role_players</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_role_const</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constant</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_ConstantGame</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strat_names</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_role_const</span> <span class="o">+</span> <span class="n">constant</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_multiply_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constant</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_ConstantGame</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strat_names</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_role_players</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_role_const</span> <span class="o">*</span> <span class="n">constant</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_game</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">othr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">othr</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_role_const</span>

    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">base</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">to_json</span><span class="p">()</span>
        <span class="n">base</span><span class="p">[</span><span class="s2">&quot;const&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_role_const</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">base</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;const.1&quot;</span>
        <span class="k">return</span> <span class="n">base</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">othr</span><span class="p">):</span>
        <span class="c1"># pylint: disable-msg=protected-access</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">othr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_role_const</span><span class="p">,</span> <span class="n">othr</span><span class="o">.</span><span class="n">_role_const</span><span class="p">)</span>

    <span class="nd">@utils</span><span class="o">.</span><span class="n">memoize</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_role_const</span><span class="p">)</span>


<div class="viewcode-block" id="const"><a class="viewcode-back" href="../../gameanalysis.rsgame.html#gameanalysis.rsgame.const">[docs]</a><span class="k">def</span> <span class="nf">const</span><span class="p">(</span><span class="n">num_role_players</span><span class="p">,</span> <span class="n">num_role_strats</span><span class="p">,</span> <span class="n">constant</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a new constant game&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">const_replace</span><span class="p">(</span><span class="n">empty</span><span class="p">(</span><span class="n">num_role_players</span><span class="p">,</span> <span class="n">num_role_strats</span><span class="p">),</span> <span class="n">constant</span><span class="p">)</span></div>


<div class="viewcode-block" id="const_names"><a class="viewcode-back" href="../../gameanalysis.rsgame.html#gameanalysis.rsgame.const_names">[docs]</a><span class="k">def</span> <span class="nf">const_names</span><span class="p">(</span><span class="n">role_names</span><span class="p">,</span> <span class="n">num_role_players</span><span class="p">,</span> <span class="n">strat_names</span><span class="p">,</span> <span class="n">constant</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a new constant game with names&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">const_replace</span><span class="p">(</span>
        <span class="n">empty_names</span><span class="p">(</span><span class="n">role_names</span><span class="p">,</span> <span class="n">num_role_players</span><span class="p">,</span> <span class="n">strat_names</span><span class="p">),</span> <span class="n">constant</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="const_replace"><a class="viewcode-back" href="../../gameanalysis.rsgame.html#gameanalysis.rsgame.const_replace">[docs]</a><span class="k">def</span> <span class="nf">const_replace</span><span class="p">(</span><span class="n">copy_game</span><span class="p">,</span> <span class="n">constant</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Replace a game with constant payoffs&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_ConstantGame</span><span class="p">(</span>
        <span class="n">copy_game</span><span class="o">.</span><span class="n">role_names</span><span class="p">,</span>
        <span class="n">copy_game</span><span class="o">.</span><span class="n">strat_names</span><span class="p">,</span>
        <span class="n">copy_game</span><span class="o">.</span><span class="n">num_role_players</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">constant</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="const_json"><a class="viewcode-back" href="../../gameanalysis.rsgame.html#gameanalysis.rsgame.const_json">[docs]</a><span class="k">def</span> <span class="nf">const_json</span><span class="p">(</span><span class="n">jgame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Read a constant game from json&quot;&quot;&quot;</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">empty_json</span><span class="p">(</span><span class="n">jgame</span><span class="p">)</span>
    <span class="n">constant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">jgame</span><span class="p">[</span><span class="s2">&quot;const&quot;</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">const_replace</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">constant</span><span class="p">)</span></div>


<span class="c1"># Legal characters for roles and strategies</span>
<span class="n">_LEG_ROLE</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">printable</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="s2">&quot;;:&quot;</span><span class="p">))</span>
<span class="n">_LEG_STRAT</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">printable</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="s2">&quot;;,&quot;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_parse_percent</span><span class="p">(</span><span class="n">perc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse percentile&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">perc</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">100</span>


<span class="k">def</span> <span class="nf">_mean</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute mean&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">cabc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">vals</span>

    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">mean</span> <span class="o">+=</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">count</span>
    <span class="k">return</span> <span class="n">mean</span> <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">)</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Game Analysis 8.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">gameanalysis.rsgame</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Strategic Reasoning Group.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>